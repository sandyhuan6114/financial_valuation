<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PDF æˆæœ¬æ™ºèƒ½åˆ†æå·¥å…·</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <!-- PDF.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Tesseract.js OCR Library -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
    <style>
      :root {
        --primary-color: #4f46e5;
        --primary-hover: #4338ca;
        --secondary-color: #06b6d4;
        --bg-color: #f3f4f6;
        --card-bg: #ffffff;
        --text-color: #1f2937;
        --text-secondary: #6b7280;
        --border-color: #e5e7eb;
        --success-color: #10b981;
        --warning-color: #f59e0b;
        --error-color: #ef4444;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: var(--text-color);
        margin: 0;
        padding: 20px;
        display: flex;
        justify-content: center;
        min-height: 100vh;
      }

      .container {
        width: 100%;
        max-width: 1200px;
      }

      header {
        text-align: center;
        margin-bottom: 40px;
        color: white;
      }

      header h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      header p {
        font-size: 1.1rem;
        opacity: 0.9;
      }

      .steps-indicator {
        display: flex;
        justify-content: space-between;
        margin-bottom: 30px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 20px;
      }

      .step-indicator {
        flex: 1;
        text-align: center;
        position: relative;
        color: white;
      }

      .step-indicator:not(:last-child)::after {
        content: "";
        position: absolute;
        top: 15px;
        right: -50%;
        width: 100%;
        height: 2px;
        background: rgba(255, 255, 255, 0.3);
        z-index: 0;
      }

      .step-indicator.active:not(:last-child)::after {
        background: var(--secondary-color);
      }

      .step-number {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-bottom: 8px;
        position: relative;
        z-index: 1;
        transition: all 0.3s;
      }

      .step-indicator.active .step-number {
        background: var(--secondary-color);
        transform: scale(1.2);
      }

      .step-indicator.completed .step-number {
        background: var(--success-color);
      }

      .step-label {
        font-size: 0.9rem;
        font-weight: 600;
      }

      .card {
        background: var(--card-bg);
        border-radius: 16px;
        padding: 32px;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1),
          0 10px 10px -5px rgba(0, 0, 0, 0.04);
        margin-bottom: 24px;
        animation: fadeInUp 0.5s ease;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      h2 {
        margin-top: 0;
        border-bottom: 2px solid var(--primary-color);
        padding-bottom: 12px;
        margin-bottom: 24px;
        color: var(--primary-color);
      }

      .upload-area {
        border: 3px dashed var(--border-color);
        border-radius: 12px;
        padding: 60px 40px;
        text-align: center;
        transition: all 0.3s;
        cursor: pointer;
        background: var(--bg-color);
      }

      .upload-area:hover,
      .upload-area.drag-over {
        border-color: var(--primary-color);
        background: #eef2ff;
        transform: translateY(-2px);
      }

      .upload-icon {
        font-size: 4rem;
        margin-bottom: 20px;
        color: var(--primary-color);
      }

      .upload-text {
        font-size: 1.2rem;
        font-weight: 600;
        margin-bottom: 8px;
      }

      .upload-hint {
        color: var(--text-secondary);
        font-size: 0.9rem;
      }

      input[type="file"] {
        display: none;
      }

      button {
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--secondary-color)
        );
        color: white;
        padding: 14px 28px;
        border: none;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
      }

      button:disabled {
        background: var(--text-secondary);
        cursor: not-allowed;
        transform: none;
      }

      .btn-secondary {
        background: white;
        color: var(--primary-color);
        border: 2px solid var(--primary-color);
      }

      .btn-secondary:hover {
        background: var(--primary-color);
        color: white;
      }

      .btn-danger {
        background: var(--error-color);
      }

      .btn-danger:hover {
        background: #dc2626;
      }

      .hidden {
        display: none !important;
      }

      .form-group {
        margin-bottom: 24px;
      }

      label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: var(--text-color);
      }

      input[type="number"] {
        width: 100%;
        padding: 12px;
        border: 2px solid var(--border-color);
        border-radius: 8px;
        font-size: 1rem;
        transition: all 0.3s;
        background: white;
      }

      input[type="number"]:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
      }

      input[type="number"]:read-only {
        background: #f9fafb;
        color: var(--text-secondary);
      }

      select.number-select {
        width: 100%;
        padding: 12px;
        border: 2px solid var(--border-color);
        border-radius: 8px;
        font-size: 1rem;
        transition: all 0.3s;
        background: white;
        cursor: pointer;
      }

      select.number-select:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
      }

      .loading {
        text-align: center;
        padding: 40px;
      }

      .spinner {
        border: 4px solid rgba(79, 70, 229, 0.1);
        border-left-color: var(--primary-color);
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .alert {
        padding: 16px;
        border-radius: 8px;
        margin-bottom: 20px;
        font-weight: 600;
      }

      .alert-info {
        background: #dbeafe;
        color: #1e40af;
        border-left: 4px solid #3b82f6;
      }

      .alert-success {
        background: #d1fae5;
        color: #065f46;
        border-left: 4px solid var(--success-color);
      }

      .alert-warning {
        background: #fef3c7;
        color: #92400e;
        border-left: 4px solid var(--warning-color);
      }

      .alert-error {
        background: #fee2e2;
        color: #991b1b;
        border-left: 4px solid var(--error-color);
      }

      .preview-container {
        margin: 20px 0;
        border: 2px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        background: #f9fafb;
      }

      .pdf-preview {
        max-width: 100%;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .extracted-data {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin: 20px 0;
      }

      @media (max-width: 768px) {
        .extracted-data {
          grid-template-columns: 1fr;
        }
      }

      .data-item {
        background: white;
        padding: 20px;
        border-radius: 8px;
        border: 2px solid var(--border-color);
        position: relative;
      }

      .data-item.auto-detected {
        border-color: var(--success-color);
      }

      .data-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }

      .data-item-label {
        font-weight: 700;
        color: var(--text-color);
      }

      .auto-badge {
        background: var(--success-color);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 600;
      }

      .data-item-value {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--primary-color);
        margin-bottom: 12px;
      }

      .edit-button {
        padding: 8px 16px;
        font-size: 0.875rem;
      }

      .actions {
        display: flex;
        gap: 12px;
        margin-top: 20px;
        justify-content: center;
        flex-wrap: wrap;
      }

      .step-card {
        background: #f9fafb;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 16px;
        position: relative;
      }

      .calc-step-number {
        position: absolute;
        top: -12px;
        left: -12px;
        background: var(--primary-color);
        color: white;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }

      .step-title {
        font-weight: 700;
        margin-bottom: 8px;
        margin-left: 10px;
        font-size: 1.1rem;
      }

      .step-desc {
        color: var(--text-secondary);
        margin-bottom: 8px;
        margin-left: 10px;
      }

      .step-math {
        background: #e0e7ff;
        padding: 12px;
        border-radius: 6px;
        font-family: "Courier New", monospace;
        font-weight: 600;
        margin-left: 10px;
        color: var(--primary-color);
      }

      .final-result {
        text-align: center;
        margin-top: 30px;
        padding: 30px;
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--secondary-color)
        );
        border-radius: 12px;
        color: white;
      }

      .final-result h3 {
        margin: 0;
        font-size: 1.5rem;
      }

      .final-result .amount {
        font-size: 2.5rem;
        font-weight: bold;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>ğŸ¤– PDF æˆæœ¬æ™ºèƒ½åˆ†æå·¥å…·</h1>
        <p>ä¸Šå‚³ PDF â†’ è‡ªå‹•è­˜åˆ¥æ•¸æ“š â†’ ç¢ºèªä¸¦è¨ˆç®—</p>
      </header>

      <!-- Steps Indicator -->
      <div class="steps-indicator">
        <div class="step-indicator active" id="stepInd1">
          <div class="step-number">1</div>
          <div class="step-label">ä¸Šå‚³ PDF</div>
        </div>
        <div class="step-indicator" id="stepInd2">
          <div class="step-number">2</div>
          <div class="step-label">ç¢ºèªæ•¸æ“š</div>
        </div>
        <div class="step-indicator" id="stepInd3">
          <div class="step-number">3</div>
          <div class="step-label">è¼¸å…¥åƒæ•¸</div>
        </div>
        <div class="step-indicator" id="stepInd4">
          <div class="step-number">4</div>
          <div class="step-label">æŸ¥çœ‹çµæœ</div>
        </div>
      </div>

      <main>
        <!-- Step 1: Upload PDF -->
        <div class="card" id="uploadSection">
          <h2>ğŸ“¤ æ­¥é©Ÿ 1: ä¸Šå‚³ PDF æª”æ¡ˆ</h2>
          <div
            class="upload-area"
            id="uploadArea"
            onclick="document.getElementById('fileInput').click()"
          >
            <div class="upload-icon">ğŸ“„</div>
            <div class="upload-text">é»æ“Šæˆ–æ‹–æ”¾ PDF æª”æ¡ˆåˆ°é€™è£¡</div>
            <div class="upload-hint">æ”¯æ´ .pdf æ ¼å¼</div>
          </div>
          <input type="file" id="fileInput" accept=".pdf" />
        </div>

        <!-- Step 2: Confirm OCR Results -->
        <div class="card hidden" id="confirmSection">
          <h2>âœ… æ­¥é©Ÿ 2: ç¢ºèª OCR è­˜åˆ¥çµæœ</h2>
          <div class="alert alert-success" id="successAlert">
            âœ“ OCR è­˜åˆ¥æˆåŠŸï¼å·²è‡ªå‹•è­˜åˆ¥ä»¥ä¸‹æ•¸æ“šã€‚
          </div>
          <div class="alert alert-warning hidden" id="warningAlert">
            âš ï¸ éƒ¨åˆ†æ•¸æ“šæœªæ‰¾åˆ°ï¼Œè«‹æ‰‹å‹•è¼¸å…¥ã€‚
          </div>

          <div class="preview-container" id="previewContainer">
            <h3 style="margin-top: 0">ğŸ“· æ¨™è¨˜é è¦½ï¼ˆæ‰¾åˆ°çš„ä½ç½®ä»¥ç´…æ¡†æ¨™ç¤ºï¼‰</h3>
            <div id="pdfCanvasContainer">
              <!-- Multiple canvases will be inserted here -->
            </div>
          </div>

          <div class="extracted-data">
            <div class="data-item auto-detected" id="totalCumulativeItem">
              <div class="data-item-header">
                <span class="data-item-label">ç¸½ç´¯è¨ˆå€¼</span>
                <span class="auto-badge" id="totalBadge">OCR è­˜åˆ¥</span>
              </div>
              <div class="data-item-value" id="totalCumulativeDisplay">-</div>
              <input type="number" id="totalCumulative" class="hidden" />
              <button
                class="edit-button btn-secondary"
                onclick="enableEdit('totalCumulative', event)"
              >
                âœï¸ ä¿®æ­£
              </button>
            </div>

            <div class="data-item auto-detected" id="amortizationItem">
              <div class="data-item-header">
                <span class="data-item-label">å„é …æ”¤æé‡‘é¡</span>
                <span class="auto-badge" id="amortBadge">OCR è­˜åˆ¥</span>
              </div>
              <div class="data-item-value" id="amortizationDisplay">-</div>
              <input type="number" id="amortization" class="hidden" />
              <button
                class="edit-button btn-secondary"
                onclick="enableEdit('amortization', event)"
              >
                âœï¸ ä¿®æ­£
              </button>
            </div>
          </div>

          <div class="actions">
            <button id="proceedToInputBtn">â¡ï¸ ç¢ºèªç„¡èª¤ï¼Œç¹¼çºŒä¸‹ä¸€æ­¥</button>
          </div>
        </div>

        <!-- Step 3: Manual Input -->
        <div class="card hidden" id="inputSection">
          <h2>âŒ¨ï¸ æ­¥é©Ÿ 3: è¼¸å…¥å…¶ä»–åƒæ•¸</h2>
          <div class="alert alert-info">è«‹è¼¸å…¥ä»¥ä¸‹ä¸‰å€‹åƒæ•¸ä»¥å®Œæˆè¨ˆç®—</div>

          <div class="form-group">
            <label for="financeDeduction">è²¡å‹™éƒ¨æä¾›æ‰£é™¤é‡‘é¡</label>
            <input
              type="number"
              id="financeDeduction"
              value="0"
              placeholder="è«‹è¼¸å…¥é‡‘é¡"
              required
            />
          </div>

          <div class="form-group">
            <label for="mgmtFee">ç®¡ç†è²» % æ•¸</label>
            <input
              type="number"
              id="mgmtFee"
              value="5"
              step="0.1"
              placeholder="ä¾‹å¦‚: 5"
              required
            />
          </div>

          <div class="form-group">
            <label for="taxPercent">ç¨…å‹™é‡‘é¡ % æ•¸</label>
            <input
              type="number"
              id="taxPercent"
              value="5"
              step="0.1"
              placeholder="ä¾‹å¦‚: 5"
              required
            />
          </div>

          <button id="calculateBtn">ğŸ§® é–‹å§‹è¨ˆç®—</button>
        </div>

        <!-- Step 4: Results -->
        <div class="card hidden" id="resultsSection">
          <h2>ğŸ“ˆ æ­¥é©Ÿ 4: è¨ˆç®—çµæœ</h2>
          <div id="stepsContainer">
            <!-- Steps will be injected here -->
          </div>
          <div class="final-result">
            <h3>æœ€çµ‚è«‹æ¬¾é‡‘é¡</h3>
            <div class="amount" id="finalAmount">-</div>
          </div>
          <div class="actions">
            <button class="btn-secondary" onclick="location.reload()">
              ğŸ”„ é‡æ–°é–‹å§‹
            </button>
          </div>
        </div>
      </main>
    </div>

    <script>
      // Configure PDF.js worker
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

      // Global variables
      let currentPdfPage = null;
      let currentPdfDocument = null; // Store PDF document
      let pdfTextItems = null;
      let extractedData = {
        totalCumulative: null,
        amortization: null,
      };
      let allPageOcrResults = []; // Store full OCR results with coordinates

      // Keywords for searching (IMPROVED)
      const KEYWORDS = {
        // Be more specific: look for "ç´¯è¨ˆå€¼" at end of line/phrase
        totalCumulative: ["ç´¯è¨ˆå€¼", "ç´¯è¨ˆè¨ˆå€¼", "ç¸½ç´¯è¨ˆå€¼"],
        // Look for "å„é …æ”¤æ" with "ç´¯è¨ˆé‡‘é¡" or "ç´¯è¨ˆ" nearby
        amortization: ["å„é …æ”¤æ"],
      };

      // Step management
      function updateStepIndicator(currentStep) {
        for (let i = 1; i <= 4; i++) {
          const stepInd = document.getElementById(`stepInd${i}`);
          stepInd.classList.remove("active", "completed");

          if (i < currentStep) {
            stepInd.classList.add("completed");
          } else if (i === currentStep) {
            stepInd.classList.add("active");
          }
        }
      }

      // File upload handling
      const uploadArea = document.getElementById("uploadArea");
      const fileInput = document.getElementById("fileInput");

      uploadArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadArea.classList.add("drag-over");
      });

      uploadArea.addEventListener("dragleave", () => {
        uploadArea.classList.remove("drag-over");
      });

      uploadArea.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadArea.classList.remove("drag-over");
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          handleFile(files[0]);
        }
      });

      fileInput.addEventListener("change", (e) => {
        if (e.target.files.length > 0) {
          handleFile(e.target.files[0]);
        }
      });

      // Handle PDF file
      async function handleFile(file) {
        if (!file.name.toLowerCase().endsWith(".pdf")) {
          alert("è«‹ä¸Šå‚³ PDF æª”æ¡ˆï¼");
          return;
        }

        // Show loading
        const uploadSection = document.getElementById("uploadSection");
        uploadSection.innerHTML = `
          <h2>ğŸ“¤ æ­¥é©Ÿ 1: ä¸Šå‚³ PDF æª”æ¡ˆ</h2>
          <div class="loading">
            <div class="spinner"></div>
            <p>æ­£åœ¨ä½¿ç”¨ OCR è­˜åˆ¥ PDF æ‰€æœ‰é é¢çš„æ–‡å­—...</p>
            <p style="color: var(--text-secondary); font-size: 0.9rem;">é è¨ˆæ¯é éœ€è¦ 5-10 ç§’ï¼Œè«‹è€å¿ƒç­‰å€™</p>
            <p style="color: var(--text-secondary); font-size: 0.85rem;">è«‹æŸ¥çœ‹ Console (F12) ä»¥äº†è§£è©³ç´°é€²åº¦</p>
          </div>
        `;

        try {
          const arrayBuffer = await file.arrayBuffer();
          await parsePDFAndExtract(arrayBuffer);

          // Update UI
          uploadSection.classList.add("hidden");
          document.getElementById("confirmSection").classList.remove("hidden");
          updateStepIndicator(2);
        } catch (error) {
          console.error("Error parsing PDF:", error);
          alert("è§£æ PDF æ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message);
          location.reload();
        }
      }

      // Parse PDF and extract data using OCR (ALL PAGES)
      async function parsePDFAndExtract(arrayBuffer) {
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        currentPdfDocument = pdf; // Save PDF document
        const totalPages = pdf.numPages;

        console.log(`=== PDF å…±æœ‰ ${totalPages} é  ===`);

        // Step 1: Render ALL pages to canvas and perform OCR
        let allOcrText = "";
        const allCanvases = [];

        for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
          console.log(`\n=== è™•ç†ç¬¬ ${pageNum}/${totalPages} é  ===`);
          const page = await pdf.getPage(pageNum);

          if (pageNum === 1) {
            currentPdfPage = page; // Save first page for preview
          }

          // Render page to canvas (high resolution for better OCR)
          console.log(`æ­¥é©Ÿ 1.${pageNum}: æ¸²æŸ“ç¬¬ ${pageNum} é ç‚ºåœ–ç‰‡`);
          const scale = 2.5;
          const viewport = page.getViewport({ scale });

          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          canvas.width = viewport.width;
          canvas.height = viewport.height;

          await page.render({
            canvasContext: ctx,
            viewport: viewport,
          }).promise;

          allCanvases.push(canvas);
          console.log(
            `ç¬¬ ${pageNum} é å·²æ¸²æŸ“: ${viewport.width}x${viewport.height}`
          );

          // OCR Recognition for this page
          console.log(
            `æ­¥é©Ÿ 2.${pageNum}: OCR è­˜åˆ¥ç¬¬ ${pageNum} é ï¼ˆç¹é«”ä¸­æ–‡ + è‹±æ–‡ï¼‰`
          );
          console.log("é è¨ˆéœ€è¦ 5-10 ç§’ï¼Œè«‹ç¨å€™...");

          const ocrResult = await Tesseract.recognize(canvas, "chi_tra+eng", {
            logger: (progress) => {
              if (progress.status === "recognizing text") {
                console.log(
                  `ç¬¬ ${pageNum} é  OCR é€²åº¦: ${(
                    progress.progress * 100
                  ).toFixed(1)}%`
                );
              }
            },
          });

          const { data } = ocrResult;
          console.log(
            `ç¬¬ ${pageNum} é  OCR å®Œæˆï¼æå–äº† ${data.text.length} å­—å…ƒ`
          );

          // Store full OCR result with coordinates
          allPageOcrResults.push({
            pageNum: pageNum,
            data: data,
            canvas: canvas,
          });

          allOcrText += `\n=== ç¬¬ ${pageNum} é  ===\n` + data.text + "\n";
        }

        console.log("\n=== æ‰€æœ‰é é¢ OCR è­˜åˆ¥å®Œæˆï¼ ===");
        console.log("åˆä½µå¾Œçš„å®Œæ•´æ–‡å­—:");
        console.log(allOcrText);
        console.log(`ç¸½å­—å…ƒæ•¸: ${allOcrText.length}`);

        // Step 3: Search for keywords in combined OCR text
        console.log("\n=== æ­¥é©Ÿ 3: æœå°‹é—œéµå­—ï¼ˆæ‰€æœ‰é é¢ï¼‰===");
        extractedData.totalCumulative = searchKeywordInOCRText(
          allOcrText,
          KEYWORDS.totalCumulative,
          "totalCumulative"
        );

        extractedData.amortization = searchKeywordInOCRText(
          allOcrText,
          KEYWORDS.amortization,
          "amortization"
        );

        // Step 4: Render all pages preview with highlights
        await renderPDFWithOCRHighlights(
          currentPdfDocument,
          allCanvases,
          allOcrText
        );

        // Step 5: Update UI
        updateExtractedDataUI();
      }

      // Search for keyword and extract number from OCR text (POSITION-BASED with BBOX)
      function searchKeywordInOCRText(text, keywords, fieldName) {
        console.log(`\næœå°‹ ${fieldName}ï¼Œé—œéµå­—:`, keywords);

        const lines = text.split("\n");

        for (let keyword of keywords) {
          console.log(`  å˜—è©¦é—œéµå­—: "${keyword}"`);

          // Search each line
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const normalizedLine = line.replace(/\s+/g, "");
            const normalizedKeyword = keyword.replace(/\s+/g, "");

            if (normalizedLine.includes(normalizedKeyword)) {
              console.log(`  âœ“ æ‰¾åˆ°é—œéµå­—åœ¨ç¬¬ ${i + 1} è¡Œ:`, lines[i]);

              const isAmortization = fieldName === "amortization";
              const isTotalCumulative = fieldName === "totalCumulative";

              // Extract ALL numbers from this line
              const lineNumbers = [];
              const words = lines[i].split(/\s+/);

              console.log(`  â†’ æå–è©²è¡Œæ‰€æœ‰æ•¸å­—...`);
              words.forEach((word) => {
                const num = extractNumber(word);
                if (num !== null && num > 1000) {
                  lineNumbers.push(num);
                  console.log(`    æ‰¾åˆ°æ•¸å­—: ${num.toLocaleString()}`);
                }
              });

              if (lineNumbers.length > 0) {
                let selectedNumber = null;

                if (isTotalCumulative) {
                  // For total cumulative, take the LARGEST number
                  selectedNumber = Math.max(...lineNumbers);
                  console.log(
                    `  âœ“ ç¸½ç´¯è¨ˆå€¼: å–æœ€å¤§æ•¸å­— = ${selectedNumber.toLocaleString()}`
                  );
                } else if (isAmortization) {
                  // For amortization, filter by range and apply OCR correction
                  const candidates = lineNumbers.filter(
                    (n) => n >= 1000000 && n <= 50000000
                  );

                  if (candidates.length > 0) {
                    console.log(
                      `  â†’ å€™é¸æ•¸å­— (1M-50M):`,
                      candidates.map((n) => n.toLocaleString())
                    );

                    // Check for OCR error: if number is 10x too large, divide by 10
                    const correctedCandidates = candidates.map((n) => {
                      if (
                        n > 10000000 &&
                        n / 10 >= 1000000 &&
                        n / 10 <= 10000000
                      ) {
                        console.log(
                          `  â†’ OCR éŒ¯èª¤ä¿®æ­£: ${n.toLocaleString()} Ã· 10 = ${(
                            n / 10
                          ).toLocaleString()}`
                        );
                        return n / 10;
                      }
                      return n;
                    });

                    // Take number closest to 4M
                    const target = 4000000;
                    selectedNumber = correctedCandidates.reduce((prev, curr) =>
                      Math.abs(curr - target) < Math.abs(prev - target)
                        ? curr
                        : prev
                    );

                    console.log(
                      `  âœ“ å„é …æ”¤æ: é¸æ“‡æœ€æ¥è¿‘ 4M çš„æ•¸å­— = ${selectedNumber.toLocaleString()}`
                    );
                  } else {
                    console.log(`  âœ— æ‰¾ä¸åˆ° 1M-50M ç¯„åœå…§çš„æ•¸å­—`);
                  }
                }

                if (selectedNumber) {
                  // Find bbox coordinates from OCR word data
                  const bbox = findBboxForValue(selectedNumber, keyword);

                  return {
                    value: selectedNumber,
                    keyword: keyword,
                    foundText: lines[i],
                    lineNumber: i + 1,
                    bbox: bbox, // Include bbox coordinates
                  };
                }
              }

              console.log(`  âœ— è©²è¡Œæ²’æœ‰æ‰¾åˆ°æœ‰æ•ˆæ•¸å­—`);
              break;
            }
          }
        }

        console.log(`  âœ— æœªæ‰¾åˆ°ä»»ä½•åŒ¹é…çš„é—œéµå­—`);
        return null;
      }

      // Find bounding box coordinates for a value from OCR word data
      function findBboxForValue(targetValue, keyword) {
        console.log(`  â†’ æœå°‹æ•¸å€¼ ${targetValue.toLocaleString()} çš„åº§æ¨™...`);

        // Search through all pages' OCR results
        for (let pageResult of allPageOcrResults) {
          const words = pageResult.data.words;
          const pageNum = pageResult.pageNum;

          // First, find the keyword
          let keywordIndex = -1;
          for (let i = 0; i < words.length; i++) {
            const wordText = words[i].text.replace(/\s+/g, "");
            const normalizedKeyword = keyword.replace(/\s+/g, "");
            if (wordText.includes(normalizedKeyword)) {
              keywordIndex = i;
              console.log(
                `    æ‰¾åˆ°é—œéµå­— "${keyword}" åœ¨ç¬¬ ${pageNum} é ï¼Œç´¢å¼• ${i}`
              );
              break;
            }
          }

          if (keywordIndex >= 0) {
            // Search for the target value near the keyword (next 20 words)
            for (
              let i = keywordIndex;
              i < Math.min(keywordIndex + 20, words.length);
              i++
            ) {
              const wordText = words[i].text;
              const num = extractNumber(wordText);

              if (num === targetValue) {
                const bbox = words[i].bbox;
                console.log(`    âœ“ æ‰¾åˆ°åŒ¹é…æ•¸å€¼çš„åº§æ¨™:`, bbox);
                return {
                  x0: bbox.x0,
                  y0: bbox.y0,
                  x1: bbox.x1,
                  y1: bbox.y1,
                  pageNum: pageNum,
                };
              }
            }
          }
        }

        console.log(`    âœ— æœªæ‰¾åˆ°æ•¸å€¼çš„ç²¾ç¢ºåº§æ¨™`);
        return null;
      }

      // Render PDF with OCR highlights (ALL PAGES)
      async function renderPDFWithOCRHighlights(
        pdfDocument,
        allCanvases,
        ocrText
      ) {
        const container = document.getElementById("pdfCanvasContainer");
        container.innerHTML = ""; // Clear

        const displayScale = 1.5; // Display scale
        const ocrScale = 2.5; // OCR scale (used when capturing text)
        const scaleFactor = displayScale / ocrScale; // Coordinate conversion factor

        // Render each page
        for (let pageIndex = 0; pageIndex < allCanvases.length; pageIndex++) {
          const pageNum = pageIndex + 1;

          // Create page wrapper
          const pageWrapper = document.createElement("div");
          pageWrapper.style.marginBottom = "30px";
          pageWrapper.style.border = "2px solid #e5e7eb";
          pageWrapper.style.borderRadius = "8px";
          pageWrapper.style.padding = "15px";
          pageWrapper.style.background = "#f9fafb";

          // Page title
          const pageTitle = document.createElement("div");
          pageTitle.style.fontWeight = "bold";
          pageTitle.style.marginBottom = "10px";
          pageTitle.style.color = "var(--primary-color)";
          pageTitle.textContent = `ç¬¬ ${pageNum} é `;
          pageWrapper.appendChild(pageTitle);

          // Get PDF page
          const page = await pdfDocument.getPage(pageNum);

          const viewport = page.getViewport({ scale: displayScale });

          const canvas = document.createElement("canvas");
          canvas.className = "pdf-preview";
          canvas.width = viewport.width;
          canvas.height = viewport.height;

          const ctx = canvas.getContext("2d");

          // Render PDF
          await page.render({
            canvasContext: ctx,
            viewport: viewport,
          }).promise;

          // Draw highlights if values found on this page
          const foundItems = [
            {
              data: extractedData.totalCumulative,
              label: "ç¸½ç´¯è¨ˆå€¼",
              color: "#ef4444",
            },
            {
              data: extractedData.amortization,
              label: "å„é …æ”¤æ",
              color: "#f59e0b",
            },
          ];

          foundItems.forEach((item) => {
            if (
              item.data &&
              item.data.bbox &&
              item.data.bbox.pageNum === pageNum
            ) {
              const bbox = item.data.bbox;

              // Convert OCR coordinates to display coordinates
              const x = bbox.x0 * scaleFactor;
              const y = bbox.y0 * scaleFactor;
              const width = (bbox.x1 - bbox.x0) * scaleFactor;
              const height = (bbox.y1 - bbox.y0) * scaleFactor;

              // Add padding to make box more visible
              const padding = 5;
              const boxX = x - padding;
              const boxY = y - padding;
              const boxWidth = width + padding * 2;
              const boxHeight = height + padding * 2;

              // Draw bounding box
              ctx.strokeStyle = item.color;
              ctx.lineWidth = 4;
              ctx.setLineDash([10, 5]);
              ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
              ctx.setLineDash([]);

              // Draw label above the box
              ctx.fillStyle = item.color;
              ctx.font = "bold 18px Arial";
              const labelText = `âœ“ ${
                item.label
              }: ${item.data.value.toLocaleString()}`;
              ctx.fillText(labelText, boxX, boxY - 10);

              console.log(`åœ¨ç¬¬ ${pageNum} é ç¹ªè£½ ${item.label} çš„é‚Šç•Œæ¡†:`, {
                x: boxX,
                y: boxY,
                width: boxWidth,
                height: boxHeight,
              });
            }
          });

          pageWrapper.appendChild(canvas);
          container.appendChild(pageWrapper);
        }

        console.log(`å·²æ¸²æŸ“ ${allCanvases.length} é  PDF é è¦½`);
      }

      // Find all large numbers in PDF
      function findAllLargeNumbers(textItems) {
        const numbers = [];
        const seen = new Set();

        for (let i = 0; i < textItems.length; i++) {
          const text = textItems[i].str.trim();
          const number = extractNumber(text);

          if (number !== null && number > 100000 && !seen.has(number)) {
            seen.add(number);
            numbers.push({
              value: number,
              keyword: "direct",
              position: textItems[i].transform,
              foundText: text,
            });
          }
        }

        // Sort by value descending
        return numbers.sort((a, b) => b.value - a.value);
      }

      // Find value near keyword
      function findKeywordValue(textItems, keywords) {
        console.log("=== é–‹å§‹æœå°‹é—œéµå­— ===", keywords);

        for (let i = 0; i < textItems.length; i++) {
          const item = textItems[i];
          const text = item.str.trim();

          for (let keyword of keywords) {
            if (text.includes(keyword)) {
              console.log(`âœ“ æ‰¾åˆ°é—œéµå­—ã€Œ${keyword}ã€åœ¨ä½ç½® ${i}:`, text);

              // Search for number in nearby items (expanded range)
              for (let j = i; j < Math.min(i + 20, textItems.length); j++) {
                const nearbyText = textItems[j].str.trim();
                const number = extractNumber(nearbyText);

                if (number !== null && number > 1000) {
                  // Filter out small numbers
                  console.log(
                    `  â†’ åœ¨ä½ç½® ${j} æ‰¾åˆ°æ•¸å­—:`,
                    number,
                    "(åŸæ–‡:",
                    nearbyText,
                    ")"
                  );
                  return {
                    value: number,
                    keyword: keyword,
                    position: textItems[j].transform,
                    foundText: nearbyText,
                  };
                } else if (number !== null) {
                  console.log(`  âœ— è·³éå°æ•¸å­—:`, number);
                }
              }
              console.log(`  âœ— åœ¨é—œéµå­—ã€Œ${keyword}ã€é™„è¿‘æ‰¾ä¸åˆ°æœ‰æ•ˆæ•¸å­—`);
            }
          }
        }

        console.log("âœ— æœªæ‰¾åˆ°ä»»ä½•åŒ¹é…çš„é—œéµå­—");
        return null;
      }

      // Extract number from text (improved to handle OCR errors)
      function extractNumber(text) {
        // Remove commas and handle OCR errors with dots
        // OCR may produce: "44ï¹’347ï¹’050" instead of "4,347,050"
        let cleaned = text.replace(/,/g, "");

        // Handle multiple dots (OCR errors) - remove all but first decimal point
        // "44ï¹’347ï¹’050" â†’ "44347050"
        cleaned = cleaned.replace(/[ï¹’.]/g, "");

        // Find all sequences of digits
        const matches = cleaned.match(/\d+/g);
        if (matches && matches.length > 0) {
          // Return the longest number sequence (most likely the actual number)
          const longestMatch = matches.reduce((a, b) =>
            a.length >= b.length ? a : b
          );
          const num = parseFloat(longestMatch);
          return isNaN(num) ? null : num;
        }
        return null;
      }

      // Render PDF with highlights
      async function renderPDFWithHighlights(page, foundItems) {
        const scale = 1.5;
        const viewport = page.getViewport({ scale });

        const canvas = document.getElementById("pdfCanvas");
        const ctx = canvas.getContext("2d");

        canvas.width = viewport.width;
        canvas.height = viewport.height;

        // Render PDF
        await page.render({
          canvasContext: ctx,
          viewport: viewport,
        }).promise;

        // Draw highlights
        foundItems.forEach((item, index) => {
          if (!item) return;

          const transform = item.position;
          const x = transform[4] * scale;
          const y = viewport.height - transform[5] * scale;

          // Draw rectangle
          ctx.strokeStyle = index === 0 ? "#ef4444" : "#f59e0b";
          ctx.lineWidth = 3;
          ctx.strokeRect(x - 10, y - 30, 200, 40);

          // Draw label
          ctx.fillStyle = index === 0 ? "#ef4444" : "#f59e0b";
          ctx.font = "bold 14px Arial";
          const label = index === 0 ? "ç¸½ç´¯è¨ˆå€¼" : "å„é …æ”¤æ";
          ctx.fillText(label, x - 10, y - 35);
        });
      }

      // Update extracted data UI with OCR results
      function updateExtractedDataUI() {
        const totalDisplay = document.getElementById("totalCumulativeDisplay");
        const amortDisplay = document.getElementById("amortizationDisplay");
        const successAlert = document.getElementById("successAlert");
        const warningAlert = document.getElementById("warningAlert");

        let foundCount = 0;

        // Total Cumulative
        if (extractedData.totalCumulative) {
          totalDisplay.textContent =
            extractedData.totalCumulative.value.toLocaleString();
          document.getElementById("totalCumulative").value =
            extractedData.totalCumulative.value;
          foundCount++;
        } else {
          totalDisplay.textContent = "æœªæ‰¾åˆ°";
          document
            .getElementById("totalCumulativeItem")
            .classList.remove("auto-detected");
          document.getElementById("totalBadge").textContent = "æ‰‹å‹•è¼¸å…¥";
          document.getElementById("totalBadge").style.background = "#f59e0b";
          enableEdit("totalCumulative");
        }

        // Amortization
        if (extractedData.amortization) {
          amortDisplay.textContent =
            extractedData.amortization.value.toLocaleString();
          document.getElementById("amortization").value =
            extractedData.amortization.value;
          foundCount++;
        } else {
          amortDisplay.textContent = "æœªæ‰¾åˆ°";
          document
            .getElementById("amortizationItem")
            .classList.remove("auto-detected");
          document.getElementById("amortBadge").textContent = "æ‰‹å‹•è¼¸å…¥";
          document.getElementById("amortBadge").style.background = "#f59e0b";
          enableEdit("amortization");
        }

        // Update alert
        if (foundCount < 2) {
          successAlert.classList.add("hidden");
          warningAlert.classList.remove("hidden");
        }

        console.log(`\nOCR çµæœ: æ‰¾åˆ° ${foundCount}/2 å€‹æ•¸å€¼`);
      }

      // Enable editing
      function enableEdit(fieldId, evt = null) {
        const input = document.getElementById(fieldId);
        const display = document.getElementById(fieldId + "Display");

        // Find the button - either from event or by querying
        let button;
        if (evt && evt.target) {
          button = evt.target;
        } else {
          // When called programmatically, find the button in the parent item
          const itemId = fieldId + "Item";
          const item = document.getElementById(itemId);
          if (item) {
            button = item.querySelector(".edit-button");
          }
        }

        if (!button) {
          console.error("Could not find button for field:", fieldId);
          // If no button found, just enable input
          input.classList.remove("hidden");
          input.removeAttribute("readonly");
          display.classList.add("hidden");
          return;
        }

        if (input.classList.contains("hidden")) {
          // Enable edit mode
          input.classList.remove("hidden");
          input.removeAttribute("readonly");
          input.focus();
          display.classList.add("hidden");
          button.textContent = "âœ“ å„²å­˜";
          button.classList.remove("btn-secondary");
          button.classList.add("btn-success");
        } else {
          // Save and disable edit mode
          const value = parseFloat(input.value);
          if (isNaN(value)) {
            alert("è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å­—ï¼");
            return;
          }
          display.textContent = value.toLocaleString();
          input.classList.add("hidden");
          display.classList.remove("hidden");
          button.textContent = "âœï¸ ä¿®æ­£";
          button.classList.add("btn-secondary");
          button.classList.remove("btn-success");
        }
      }

      // Proceed to input
      document
        .getElementById("proceedToInputBtn")
        .addEventListener("click", () => {
          document.getElementById("confirmSection").classList.add("hidden");
          document.getElementById("inputSection").classList.remove("hidden");
          updateStepIndicator(3);
        });

      // Calculate button
      document.getElementById("calculateBtn").addEventListener("click", () => {
        // Get all values
        const totalCumulative = parseFloat(
          document.getElementById("totalCumulative").value
        );
        const amortization = parseFloat(
          document.getElementById("amortization").value
        );
        const financeDeduction = parseFloat(
          document.getElementById("financeDeduction").value
        );
        const mgmtFeePercent = parseFloat(
          document.getElementById("mgmtFee").value
        );
        const taxPercent = parseFloat(
          document.getElementById("taxPercent").value
        );

        // Validate
        if (
          isNaN(totalCumulative) ||
          isNaN(amortization) ||
          isNaN(financeDeduction) ||
          isNaN(mgmtFeePercent) ||
          isNaN(taxPercent)
        ) {
          alert("è«‹ç¢ºä¿æ‰€æœ‰æ¬„ä½éƒ½å·²å¡«å¯«ï¼");
          return;
        }

        // Calculate
        const steps = calculateSteps(
          totalCumulative,
          financeDeduction,
          mgmtFeePercent,
          amortization,
          taxPercent
        );

        // Display results
        displayResults({ steps });

        // Update UI
        document.getElementById("inputSection").classList.add("hidden");
        document.getElementById("resultsSection").classList.remove("hidden");
        updateStepIndicator(4);
      });

      // Calculate steps
      function calculateSteps(
        totalCumulative,
        financeDeduction,
        managementFeePercent,
        amortization,
        taxPercent
      ) {
        const steps = [];

        // Step 1
        steps.push({
          step: 1,
          title: "åˆå§‹å€¼ (ç¸½ç´¯è¨ˆå€¼)",
          description: "è¼¸å…¥çš„ç¸½ç´¯è¨ˆå€¼",
          math: totalCumulative.toLocaleString(),
          result: totalCumulative,
        });

        // Step 2
        const step2Res = totalCumulative - financeDeduction;
        steps.push({
          step: 2,
          title: "æ‰£é™¤ è²¡å‹™éƒ¨æä¾›æ‰£é™¤é‡‘é¡",
          description: `æ‰£é™¤è¼¸å…¥çš„é‡‘é¡: ${financeDeduction.toLocaleString()}`,
          math: `${totalCumulative.toLocaleString()} - ${financeDeduction.toLocaleString()} = ${step2Res.toLocaleString()}`,
          result: step2Res,
        });

        // Step 3
        const mgmtFee = step2Res * (managementFeePercent / 100);
        const mgmtFeeRounded = Math.round(mgmtFee);
        const step3Res = step2Res + mgmtFeeRounded;
        steps.push({
          step: 3,
          title: "åŠ ä¸Š ç®¡ç†è²»",
          description: `åŠ ä¸Š ${managementFeePercent}% ç®¡ç†è²»`,
          math: `${step2Res.toLocaleString()} * ${managementFeePercent}% â‰ˆ ${mgmtFeeRounded.toLocaleString()} (åŠ ç¸½: ${step3Res.toLocaleString()})`,
          result: step3Res,
        });

        // Step 4
        const step4Res = step3Res - amortization;
        steps.push({
          step: 4,
          title: "æ‰£é™¤ å„é …æ”¤æ",
          description: `æ‰£é™¤è¼¸å…¥çš„å„é …æ”¤æ: ${amortization.toLocaleString()}`,
          math: `${step3Res.toLocaleString()} - ${amortization.toLocaleString()} = ${step4Res.toLocaleString()}`,
          result: step4Res,
        });

        // Step 5
        const tax = step4Res * (taxPercent / 100);
        const taxRounded = Math.round(tax);
        const step5Res = step4Res + taxRounded;
        steps.push({
          step: 5,
          title: "åŠ ä¸Š ç‡Ÿæ¥­ç¨… (æœ€çµ‚çµæœ)",
          description: `åŠ ä¸Š ${taxPercent}% ç‡Ÿæ¥­ç¨…`,
          math: `${step4Res.toLocaleString()} * ${taxPercent}% â‰ˆ ${taxRounded.toLocaleString()} (æœ€çµ‚: ${step5Res.toLocaleString()})`,
          result: step5Res,
        });

        return steps;
      }

      // Display results
      function displayResults(data) {
        const stepsContainer = document.getElementById("stepsContainer");
        const finalAmount = document.getElementById("finalAmount");

        stepsContainer.innerHTML = "";

        data.steps.forEach((step) => {
          const stepDiv = document.createElement("div");
          stepDiv.className = "step-card";
          stepDiv.innerHTML = `
            <div class="calc-step-number">${step.step}</div>
            <div class="step-title">${step.title}</div>
            <div class="step-desc">${step.description}</div>
            <div class="step-math">${step.math}</div>
          `;
          stepsContainer.appendChild(stepDiv);
        });

        const lastStep = data.steps[data.steps.length - 1];
        finalAmount.textContent = lastStep.result.toLocaleString();
      }
    </script>
  </body>
</html>
